# -*- coding: utf-8 -*-
"""SVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13fjq5d4N5atSwhfcXAB_fQVG3kFLjUMk

#Support Vectorial Machine
"""

import matplotlib.pyplot as plt
import numpy as np
import cvxopt

"""# SVM plotting"""

def plot_svm(x, y, model, C, gamma):        
    plt.figure(figsize=(8, 6))
      
    plt.plot(x[y == 1, 0], x[y == 1, 1],'bo', markersize=4)
    plt.plot(x[y == -1, 0], x[y == -1, 1], 'ro',markersize=4)
        
    xmin, xmax = x[:,0].min()-0.5, x[:,0].max()+0.5
    ymin, ymax = x[:,1].min()-0.5, x[:,1].max()+0.5  
    
    xx, yy = np.meshgrid(np.linspace(xmin, xmax, 100), 
                         np.linspace(ymin, ymax, 100))
    data = np.array([xx.ravel(), yy.ravel()]).T
    zz = model.project(data).reshape(xx.shape)
    plt.contour(xx, yy, zz, [0.0], colors='k', linewidths=2)
    plt.contour(xx, yy, zz, [-1.0, 1.0], colors='grey',
                linestyles='--', linewidths=2)
    plt.contourf(xx, yy, zz, [min(zz.ravel()), 0.0, max(zz.ravel())],alpha=0.8, 
                 cmap=plt.cm.RdBu )
    
    plt.scatter(model.sv[:, 0], model.sv[:, 1], s=200, color="gold")  
    
    plt.xlabel(r'$x_1$', fontsize=10)
    plt.ylabel(r'$x_2$', fontsize=10)
    plt.title('SVM, C = '+str(C)+", gamma="+str(gamma), fontsize=15)
    plt.xlim([xmin,xmax])
    plt.ylim([ymin,ymax])
    plt.grid()
    plt.show()

"""# Class"""

class SVM():
    def __init__(self, kernel='linear', C=0.001, gamma=0.001, degree=3):
        #Parametros
        self.C = float(C)
        self.gamma = float(gamma)
        self.d = int(degree)
        
        if kernel == 'linear':
            self.kernel = self.linear
        elif kernel == 'polynomial':
            self.kernel = self.polynomial
        elif kernel == 'gaussian':
            self.kernel = self.gaussian
        else:
            raise NameError('Unknown kernel')
        
    #kernel functions
    def linear(self,x1,x2):
        return np.dot(x1,x2)
    def polynomial(self,x1,x2):
        return (np.dot(x1,x2) + 1) ** self.d
    def gaussian(self, x1, x2):
        diff = x1 - x2
        norm_squared = np.linalg.norm(diff) ** 2
        kernel_value = np.exp(-self.gamma * norm_squared)
        return kernel_value
    
    
    def fit(self, X, y):
        n_samples, n_features = X.shape
        
        K = np.zeros((n_samples,n_samples))
        for i in range(n_samples):
            for j in range(n_samples):
                K[i,j] = self.kernel(X[i], X[j])
        
        #Solve quadratic problem ---------------------------
        P = cvxopt.matrix(np.outer(y,y)*K)
        q = cvxopt.matrix(-1 * np.ones(n_samples))
        A = cvxopt.matrix(y, (1, n_samples))
        b = cvxopt.matrix(0.0)
        
        if self.C == 0:
            G = cvxopt.matrix(np.identity(n_samples)* -1)
            h = cvxopt.matrix(np.zeros(n_samples))
        else:
            tmp1 = np.identity(n_samples) * -1
            tmp2 = np.identity(n_samples)
            G = cvxopt.matrix(np.vstack((tmp1,tmp2)))
            
            tmp1 = np.zeros(n_samples)
            tmp2 = self.C * np.ones(n_samples)
            h = cvxopt.matrix(np.hstack((tmp1, tmp2)))
        
        cvxopt.solvers.options['show_progress'] = False
        solution = cvxopt.solvers.qp(P, q, G, h, A, b)
        #----------------------------------------------------

        lamb = np.ravel(solution['x'])
        mask = lamb > 1e-5
        ind = np.arange(len(lamb))[mask]
        self.lamb = lamb[mask]
        
        #Extract support vectors
        self.sv = X[mask]
        self.sv_y = y[mask]
        
        #Calculate b
        self.b = 0
        for i in range(len(self.lamb)):
            self.b += self.sv_y[i]
            self.b -= np.sum(self.lamb * self.sv_y * K[ind[i], mask])
        self.b = self.b / len(self.lamb)
        
    def project(self, X):
        y_predict = np.zeros(len(X))
        for i in range(len(X)):
            s = 0
            for a, sv_y, sv in zip(self.lamb, self.sv_y, self.sv):
                s += a * sv_y * self.kernel(X[i], sv)
            y_predict[i] = s
        return y_predict + self.b
    
    def predict(self, X):
        return np.sign(self.project(X))

"""# Principal"""

from sklearn.datasets import make_moons

x = np.genfromtxt("moons.csv", delimiter=',', skip_header=1, usecols=[0, 1])
y = np.genfromtxt("moons.csv", delimiter=',', skip_header=1, usecols=[2]).reshape(1, -1)[0]
y = np.asanyarray(y, dtype=np.float64)
y += (y==0) * -1.0

C, gamma = 1, 0.4

model = SVM(kernel = 'gaussian', C=C, gamma=gamma)
model.fit(x, y)
plot_svm(x, y, model, C, gamma)